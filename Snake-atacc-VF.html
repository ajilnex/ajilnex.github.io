<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Famille</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Bebas Neue', sans-serif;
            color: #fff;
        }
        
        #gameContainer {
            position: relative;
            border: 4px solid #f00;
            background: #000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            padding: 30px;
        }
        
        #gameCanvas {
            display: block;
            background: #111;
            border: 2px solid #700;
        }
        
        #ui {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .score {
            font-size: 24px;
            color: #f00;
        }
        
        .title {
            font-size: 32px;
            color: #fff;
            text-shadow: 2px 2px 0 #f00;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #f00;
            text-shadow: 2px 2px 0 #000;
            display: none;
            animation: shake 0.5s infinite;
            z-index: 10;
        }
        
        #startBtn {
            display: block;
            margin: 10px auto 0;
            padding: 10px 20px;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 20px;
            background: #f00;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        
        #startBtn:hover {
            background: #c00;
        }
        
        .nameAnimation {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            color: #ff0;
            text-shadow: 2px 2px 0 #f00;
            opacity: 0;
            display: none;
        }
        
        .nameAnimation.show {
            display: block;
            animation: nameComplete 2s ease-out;
        }
        
        #completedNames {
            position: absolute;
            right: -150px;
            top: 0;
            width: 140px;
            background: rgba(0, 0, 0, 0.8);
            border-left: 2px solid #f00;
            padding: 10px;
            height: 100%;
            overflow-y: auto;
        }
        
        .nameEntry {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid #500;
        }
        
        .nameMultiplier {
            color: #ff0;
        }
        
        #speedIndicator {
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 14px;
            color: #ff0;
        }
        
        @keyframes shake {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            25% { transform: translate(-52%, -48%) rotate(-2deg); }
            50% { transform: translate(-50%, -52%) rotate(2deg); }
            75% { transform: translate(-48%, -50%) rotate(-1deg); }
            100% { transform: translate(-50%, -50%) rotate(0deg); }
        }
        
        @keyframes nameComplete {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div class="score">SCORE: <span id="score">0</span></div>
            <div class="title">SNAKE FAMILLE</div>
            <div class="score">MEILLEUR: <span id="highScore">0</span></div>
        </div>
        
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        
        <div id="gameOver">GAME OVER</div>
        <div id="nameComplete" class="nameAnimation">NOM COMPLET!</div>
        <div id="speedIndicator">VITESSE: x1.0</div>
        <button id="startBtn">COMMENCER</button>
        
        <div id="completedNames">
            <h3 style="color:#f00;margin-top:0;text-align:center;border-bottom:1px solid #f00;padding-bottom:5px;">NOMS COMPLÉTÉS</h3>
            <div id="namesList"></div>
        </div>
    </div>

    <script>
        // Éléments du DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const gameOverElement = document.getElementById('gameOver');
        const startButton = document.getElementById('startBtn');
        const nameCompleteElement = document.getElementById('nameComplete');
        const namesListElement = document.getElementById('namesList');
        const speedIndicator = document.getElementById('speedIndicator');
        
        // Configuration du jeu
        const gridSize = 20;
        const tileCountX = canvas.width / gridSize;
        const tileCountY = canvas.height / gridSize;
        
        // Liste des noms de famille
        const nameWords = ["CAMILLE", "AUBIN", "CLOTILDE", "TANCREDE", "ALIX", "VIRGINIE", "FREDERIC", "ROBERT"];
        
        // Variables du jeu
        let snake = [];
        let food = {};
        let dx = 1;
        let dy = 0;
        let score = 0;
        let highScore = 0;
        let gameRunning = false;
        let gameLoop;
        let currentNameIndex = 0;
        let currentLetterIndex = 0;
        let nextDirection = {dx: 1, dy: 0};
        let completedNamesMap = {};
        let gameSpeed = 150; // Vitesse initiale
        let baseSpeed = 150; // Pour calculer le multiplicateur
        let speedMultiplier = 1;
        
        // Initialiser le compteur de noms
        nameWords.forEach(name => {
            completedNamesMap[name] = 0;
        });
        
        // Fonction d'initialisation
        function initGame() {
            // Réinitialiser le serpent
            snake = [
                {x: 10, y: 10},
                {x: 9, y: 10},
                {x: 8, y: 10}
            ];
            
            // Réinitialiser la direction et les variables
            dx = 1;
            dy = 0;
            nextDirection = {dx: 1, dy: 0};
            score = 0;
            currentNameIndex = 0;
            currentLetterIndex = 0;
            gameSpeed = baseSpeed;
            speedMultiplier = 1;
            
            // Mettre à jour l'affichage
            scoreElement.textContent = score;
            gameOverElement.style.display = 'none';
            speedIndicator.textContent = "VITESSE: x1.0";
            
            // Générer la première nourriture
            generateFood();
        }
        
        // Fonction pour générer une nouvelle nourriture
        function generateFood() {
            let validPosition = false;
            
            while (!validPosition) {
                food.x = Math.floor(Math.random() * tileCountX);
                food.y = Math.floor(Math.random() * tileCountY);
                
                validPosition = true;
                
                // Vérifier que la nourriture n'est pas sur le serpent
                for (let part of snake) {
                    if (part.x === food.x && part.y === food.y) {
                        validPosition = false;
                        break;
                    }
                }
            }
        }
        
        // Fonction pour suivre la progression des noms
        function trackNameProgress() {
            const currentWord = nameWords[currentNameIndex];
            currentLetterIndex++;
            
            if (currentLetterIndex >= currentWord.length) {
                // Nom complet !
                completeCurrentName(currentWord);
                
                // Passer au nom suivant
                currentNameIndex = (currentNameIndex + 1) % nameWords.length;
                currentLetterIndex = 0;
                
                // Bonus de points
                score += 50;
                scoreElement.textContent = score;
                
                // Accélération supplémentaire
                speedUp(0.95);
            }
        }
        
        // Fonction pour marquer un nom comme complété
        function completeCurrentName(name) {
            // Incrémenter le compteur pour ce nom
            completedNamesMap[name]++;
            
            // Mettre à jour l'affichage des noms complétés
            updateCompletedNamesList();
            
            // Afficher l'animation
            let completionText = name;
            if (completedNamesMap[name] > 1) {
                completionText += " x" + completedNamesMap[name];
            }
            
            nameCompleteElement.textContent = completionText + " COMPLET!";
            nameCompleteElement.classList.remove('show');
            void nameCompleteElement.offsetWidth; // Force reflow
            nameCompleteElement.classList.add('show');
        }
        
        // Mise à jour de la liste des noms complétés
        function updateCompletedNamesList() {
            namesListElement.innerHTML = '';
            
            // Trier les noms par nombre de complétion
            const sortedNames = Object.keys(completedNamesMap).sort((a, b) => 
                completedNamesMap[b] - completedNamesMap[a]
            );
            
            sortedNames.forEach(name => {
                if (completedNamesMap[name] > 0) {
                    const div = document.createElement('div');
                    div.className = 'nameEntry';
                    div.innerHTML = `
                        <span>${name}</span>
                        <span class="nameMultiplier">x${completedNamesMap[name]}</span>
                    `;
                    namesListElement.appendChild(div);
                }
            });
        }
        
        // Fonction pour accélérer le jeu
        function speedUp(factor) {
            if (gameSpeed > 50) { // Limite de vitesse pour garder le jeu jouable
                gameSpeed *= factor;
                speedMultiplier = baseSpeed / gameSpeed;
                
                // Mettre à jour l'indicateur de vitesse
                speedIndicator.textContent = `VITESSE: x${speedMultiplier.toFixed(1)}`;
                
                // Redémarrer la boucle de jeu à la nouvelle vitesse
                if (gameRunning) {
                    clearInterval(gameLoop);
                    gameLoop = setInterval(gameLogicTick, gameSpeed);
                }
            }
        }
        
        // Dessiner le serpent
        function drawSnake() {
            for (let i = 0; i < snake.length; i++) {
                const part = snake[i];
                
                if (i === 0) {
                    // Tête
                    ctx.fillStyle = '#f00';
                    ctx.fillRect(part.x * gridSize, part.y * gridSize, gridSize, gridSize);
                    
                    // Yeux
                    ctx.fillStyle = '#fff';
                    // Position des yeux selon la direction
                    if (dx === 1) { // droite
                        ctx.fillRect(part.x * gridSize + 14, part.y * gridSize + 4, 4, 4);
                        ctx.fillRect(part.x * gridSize + 14, part.y * gridSize + 12, 4, 4);
                    } else if (dx === -1) { // gauche
                        ctx.fillRect(part.x * gridSize + 2, part.y * gridSize + 4, 4, 4);
                        ctx.fillRect(part.x * gridSize + 2, part.y * gridSize + 12, 4, 4);
                    } else if (dy === -1) { // haut
                        ctx.fillRect(part.x * gridSize + 4, part.y * gridSize + 2, 4, 4);
                        ctx.fillRect(part.x * gridSize + 12, part.y * gridSize + 2, 4, 4);
                    } else { // bas
                        ctx.fillRect(part.x * gridSize + 4, part.y * gridSize + 14, 4, 4);
                        ctx.fillRect(part.x * gridSize + 12, part.y * gridSize + 14, 4, 4);
                    }
                } else {
                    // Corps avec lettres
                    ctx.fillStyle = '#444';
                    ctx.fillRect(part.x * gridSize, part.y * gridSize, gridSize, gridSize);
                    
                    ctx.strokeStyle = '#700';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(part.x * gridSize, part.y * gridSize, gridSize, gridSize);
                    
                    // Afficher la lettre correspondante
                    ctx.fillStyle = '#f00';
                    ctx.font = '14px Bebas Neue';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Calculer quelle lettre afficher
                    const segmentIndex = i - 1;
                    let letterToShow = '';
                    let nameIndex = 0;
                    let letterIndex = 0;
                    let letterCount = 0;
                    
                    // Trouver à quel nom cette partie appartient
                    for (let j = 0; j < nameWords.length; j++) {
                        if (letterCount + nameWords[j].length > segmentIndex) {
                            nameIndex = j;
                            letterIndex = segmentIndex - letterCount;
                            break;
                        }
                        letterCount += nameWords[j].length;
                    }
                    
                    // Si on a dépassé tous les noms, recommencer du début
                    if (letterCount <= segmentIndex) {
                        const totalLength = nameWords.reduce((sum, name) => sum + name.length, 0);
                        const adjustedIndex = segmentIndex % totalLength;
                        
                        // Recalculer
                        letterCount = 0;
                        for (let j = 0; j < nameWords.length; j++) {
                            if (letterCount + nameWords[j].length > adjustedIndex) {
                                nameIndex = j;
                                letterIndex = adjustedIndex - letterCount;
                                break;
                            }
                            letterCount += nameWords[j].length;
                        }
                    }
                    
                    letterToShow = nameWords[nameIndex][letterIndex];
                    
                    ctx.fillText(
                        letterToShow,
                        part.x * gridSize + gridSize / 2,
                        part.y * gridSize + gridSize / 2
                    );
                }
            }
        }
        
        // Dessiner la nourriture
        function drawFood() {
            ctx.fillStyle = '#f00';
            ctx.fillRect(food.x * gridSize + 4, food.y * gridSize + 4, gridSize - 8, gridSize - 8);
            
            // Croix au centre
            ctx.fillStyle = '#fff';
            ctx.fillRect(food.x * gridSize + gridSize/2 - 1, food.y * gridSize + 4, 2, gridSize - 8);
            ctx.fillRect(food.x * gridSize + 4, food.y * gridSize + gridSize/2 - 1, gridSize - 8, 2);
        }
        
        // Déplacer le serpent
        function moveSnake() {
            dx = nextDirection.dx;
            dy = nextDirection.dy;
            
            const head = {x: snake[0].x + dx, y: snake[0].y + dy};
            
            // Vérifier les collisions avec les murs
            if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY) {
                gameOver();
                return;
            }
            
            // Vérifier les collisions avec le corps
            for (let i = 0; i < snake.length; i++) {
                if (snake[i].x === head.x && snake[i].y === head.y) {
                    gameOver();
                    return;
                }
            }
            
            // Ajouter la nouvelle tête
            snake.unshift(head);
            
            // Vérifier si on mange la nourriture
            if (head.x === food.x && head.y === food.y) {
                // Augmenter le score
                score += 10;
                scoreElement.textContent = score;
                
                // Générer nouvelle nourriture
                generateFood();
                
                // Suivre la progression du nom
                trackNameProgress();
                
                // Légère accélération
                speedUp(0.98);
            } else {
                // Si on ne mange pas, retirer la queue
                snake.pop();
            }
        }
        
        // Game over
        function gameOver() {
            gameRunning = false;
            clearInterval(gameLoop);
            gameOverElement.style.display = 'block';
            startButton.textContent = 'REJOUER';
            
            if (score > highScore) {
                highScore = score;
                highScoreElement.textContent = highScore;
            }
        }
        
        // Logique principale du jeu (appelée à chaque tick)
        function gameLogicTick() {
            // Effacer le canvas
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner la grille
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < tileCountX; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
            }
            
            for (let i = 0; i < tileCountY; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }
            
            // Dessiner le contour du terrain
            ctx.strokeStyle = '#f00';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
            
            // Déplacer et dessiner
            moveSnake();
            drawFood();
            drawSnake();
        }
        
        // Démarrer le jeu
        function startGame() {
            if (gameRunning) return;
            
            initGame();
            gameRunning = true;
            gameLoop = setInterval(gameLogicTick, gameSpeed);
            startButton.textContent = 'EN COURS';
        }
        
        // Changer la direction
        function changeDirection(event) {
            if (!gameRunning) return;
            
            const key = event.key.toLowerCase();
            
            if ((key === 'arrowleft' || key === 'q' || key === 'a') && dx !== 1) {
                nextDirection = {dx: -1, dy: 0};
            } else if ((key === 'arrowup' || key === 'z' || key === 'w') && dy !== 1) {
                nextDirection = {dx: 0, dy: -1};
            } else if ((key === 'arrowright' || key === 'd') && dx !== -1) {
                nextDirection = {dx: 1, dy: 0};
            } else if ((key === 'arrowdown' || key === 's') && dy !== -1) {
                nextDirection = {dx: 0, dy: 1};
            }
            
            if(['arrowleft', 'arrowup', 'arrowright', 'arrowdown'].includes(key)) {
                event.preventDefault();
            }
        }
        
        // Support tactile pour les appareils mobiles
        let touchStartX = 0;
        let touchStartY = 0;
        
        document.addEventListener('touchstart', function(e) {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        });
        
        document.addEventListener('touchend', function(e) {
            if (!gameRunning) return;
            
            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            
            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;
            
            if (Math.abs(diffX) > Math.abs(diffY)) {
                // Swipe horizontal
                if (diffX > 0 && dx !== -1) {
                    nextDirection = {dx: 1, dy: 0}; // Droite
                } else if (diffX < 0 && dx !== 1) {
                    nextDirection = {dx: -1, dy: 0}; // Gauche
                }
            } else {
                // Swipe vertical
                if (diffY > 0 && dy !== -1) {
                    nextDirection = {dx: 0, dy: 1}; // Bas
                } else if (diffY < 0 && dy !== 1) {
                    nextDirection = {dx: 0, dy: -1}; // Haut
                }
            }
            
            e.preventDefault();
        });
        
        // Gestionnaires d'événements
        document.addEventListener('keydown', changeDirection);
        startButton.addEventListener('click', startGame);
        
        // Initialiser et attendre le démarrage
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Contour du terrain
        ctx.strokeStyle = '#f00';
        ctx.lineWidth = 2;
        ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
        
        // Instructions
        ctx.fillStyle = '#fff';
        ctx.font = '20px Bebas Neue';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('APPUYEZ SUR COMMENCER POUR JOUER', canvas.width / 2, canvas.height / 2 - 30);
        ctx.font = '16px Bebas Neue';
        ctx.fillText('UTILISEZ LES FLÈCHES OU ZQSD POUR VOUS DÉPLACER', canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText('COLLECTEZ LES LETTRES POUR COMPLÉTER LES NOMS', canvas.width / 2, canvas.height / 2 + 50);
    </script>
</body>
</html>